# SWAN Default Configuration for Local Models
work_dir: "./work"

providers:
#  - name: "openai-gpt-4o"
#    provider: "openai"
#    model: "gpt-4o"
#    immutable: true
  - name: "ollama-gemma3-1b"
    provider: "ollama"
    model: "gemma3:1b"
    baseurl: "http://localhost:11434"
    immutable: true
  - name: "ollama-gemma3-12b"
    provider: "ollama"
    model: "gemma3:12b"
    baseurl: "http://localhost:11434"
    immutable: true

mcps:
  - name: "wttr"
    type: "wttr"
    command: "mai-mcp-wttr"
    args: []
    config:
      enabled: true
    immutable: true
  - name: "pancode"
    type: "pancode"
    command: "mai-mcp-pancode"
    args: []
    config:
      enabled: true
    immutable: true
  - name: "time"
    type: "time"
    command: "mai-mcp-time"
    args: []
    config:
      enabled: true
    immutable: true
  - name: "shell"
    type: "shell"
    command: "mai-mcp-shell"
    args: []
    config:
      enabled: true
    immutable: true


prompts:
  - name: "default-system"
    content: "You are a helpful AI assistant running locally with access to various tools."
    type: "system"
    immutable: true
  - name: "coding-assistant"
    content: "You are a specialized coding assistant with access to code analysis and shell tools."
    type: "system"
    immutable: true
  - name: "research-assistant"
    content: "You are a research assistant with access to weather information and time tools."
    type: "system"
    immutable: true

agents:
  - name: "agent-gemma3-1b"
    provider: "ollama-gemma3-1b"
    mcps: ["shell", "time"]
    prompts: ["default-system"]
    immutable: true
  - name: "agent-gemma3-12b"
    provider: "ollama-gemma3-12b"
    mcps: ["pancode", "shell", "wttr", "time"]
    prompts: ["coding-assistant"]
    immutable: true

orchestrator:
  port: 9090
  listen_addr: "127.0.0.1"

# SWAN's own prompts - can be customized and will evolve over time
swan_prompts:
  rules: |
    You are SWAN, an intelligent multi-agent orchestration system. Your core rules:
    1. Always prioritize quality over speed, but balance both metrics
    2. Learn from mistakes and continuously improve decision making
    3. Cache high-quality responses from slow models to accelerate future queries
    4. Run evaluation competitions for important decisions
    5. Enable inter-agent communication for collaborative learning
    6. Maintain network knowledge files for each agent
    7. Evolve your own prompts and configurations autonomously

  reasoning: |
    When making decisions, consider:
    - Historical performance metrics (time, quality, success rate)
    - Query similarity to past tasks
    - Agent specialization and capabilities
    - Current system load and resource availability
    - Cached responses availability
    - Network knowledge from inter-agent interactions
    - Recent evaluation competition results

  quality_eval: |
    Evaluate response quality based on:
    - Accuracy and correctness (0.4 weight)
    - Completeness and comprehensiveness (0.3 weight)
    - Clarity and readability (0.2 weight)
    - Efficiency and conciseness (0.1 weight)
    - Score from 0.0 to 1.0, where 0.8+ is high quality

  competition: |
    For evaluation competitions:
    1. Select 2-3 agents with different characteristics (speed vs accuracy)
    2. Give them identical tasks
    3. Compare responses using quality evaluation criteria
    4. Record winner and reasoning
    5. Update agent performance metrics
    6. Consider changing agent configurations based on results

  learning: |
    Learning process:
    1. Record all task executions with metrics
    2. Detect mistakes and log corrections
    3. Update agent performance profiles
    4. Store successful patterns in VDB cache
    5. Share learnings through inter-agent communication
    6. Evolve prompts and configurations based on experience

  evolution: |
    Autonomous evolution guidelines:
    1. Monitor system performance trends
    2. Identify bottlenecks and improvement opportunities
    3. Modify agent configurations for better performance
    4. Update your own prompts based on learning
    5. Add new agents when needed
    6. Remove underperforming agents
    7. Document all changes and their rationale
